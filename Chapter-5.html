<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <title>Chapter 5</title>
</head>
<body>

    <main>
        
        <section>
            <article>
                <h1>System Modeling</h1>
                <hr>

                <h2>Objectives</h2>
                <p>The aim of this chapter is to introduce some types of system model that may be developed as part of the requirements engineering and system design processes. When you have read the chapter, you will:</p>
                
                <ul>
                    <li>understand how graphical models can be used to represent software systems;</li>
                    <li>understand why different types of model are required and the fundamental system modeling perspectives of context interaction, structure, and behavior;</li>
                    <li>have been introduced to some of the diagram types in the Unified Modeling Language (UML) and how these diagrams may be used in system modeling;</li>
                    <li>be aware of the ideas underlying model-driven engineering, where a system is automatically generated from structural and behavioral models.</li>
                </ul>
            </article>

            <article>
                <h2>Contents</h2> 
                <ol>
                    <li>Context models</li>
                    <li>Interaction models</li>
                    <li>Structural models</li>
                    <li>Behavioral models</li>
                    <li>Model-driven engineering</li>
                </ol>
                <p>System modeling involves creating abstract models that show different views or perspectives of a system. It's typically done using graphical notations, most commonly based on the Unified Modeling Language (UML). However, formal (mathematical) models can also be used, mainly for detailed specifications. This chapter focuses on graphical UML modeling, while formal modeling is covered in Chapter 12.</p>
            </article>

            <article>
                <p>Models are used during the requirements engineering process to help derive the requirements for a system, during the design process to describe the system to engineers implementing the system and after implementation to document the system’s structure and operation. You may develop models of both the existing system and the system to be developed:</p>
                <ol>
                    <li>Models of the existing system are used during requirements engineering. They help clarify what the existing system does and can be used as a basis for discussing its strengths and weaknesses. These then lead to requirements for the new system.</li>
                    <li>Models of the new system are used during requirements engineering to help explain the proposed requirements to other system stakeholders. Engineers use these models to discuss design proposals and to document the system for implementation. In a model-driven engineering process, it is possible to generate a complete or partial system implementation from the system model.</li>
                </ol>

                <p>A system model is an abstraction, not a full representation—it deliberately omits detail to highlight the most important aspects of the system. While a representation aims to preserve all information (like a translation), an abstraction simplifies to focus on key features (like a newspaper summary of a book).</p>
                <p>You may develop different models to represent the system from different perspectives. For example:</p>

                <ol>
                    <li>An external perspective, where you model the context or environment of the system.</li>
                    <li>An interaction perspective where you model the interactions between a system and its environment or between the components of a system.</li>
                    <li>A structural perspective, where you model the organization of a system or the structure of the data that is processed by the system.</li>
                    <li>A behavioral perspective, where you model the dynamic behavior of the system and how it responds to events.</li>
                </ol>

                <p>This section explains that system architecture should be documented from multiple perspectives, aligning with Kruchten’s 4 + 1 view model, which is covered in Chapter 6.</p>
            </article>

            <article>
                <p>In this chapter, system modeling is done using the Unified Modeling Language (UML)—a standard for object-oriented modeling. UML includes many diagram types, but a 2007 survey found that five key types are most commonly used to capture a system’s essentials:</p>

                <ol>
                    <li><strong>Activity diagrams</strong>– represent processes or data processing workflows.</li>
                    <li><strong>Use case diagrams</strong> – show system interactions with its environment.</li>
                    <li><strong>Sequence diagrams</strong> – illustrate interactions over time between actors and system components.</li>
                    <li><strong>Class diagrams</strong> – define object classes and their relationships.</li>
                    <li><strong>State diagrams</strong> – depict how the system responds to events.</li>
                </ol>

                <p>This section emphasizes that, due to space constraints, only the five key UML diagram types are discussed.</p>
                <p>When creating system models, there is <strong>flexibility</strong> in how strictly you follow UML notations—the level of <strong>detail and formality</strong> should match the model's purpose. Graphical models are typically used in three main ways:</p>
                <ol>
                    <li>To facilitate discussion about an existing or proposed system.</li>
                    <li>To document an existing system.</li>
                    <li>To provide a detailed description that can support system implementation.</li>
                </ol>

                <p>Models used to support discussion among software engineers—especially in agile modeling—can be incomplete and use informal notation, as long as they effectively communicate key ideas. Their main goal is to facilitate understanding, not to serve as formal documentation. On the other hand, when models are used for documentation, they don't need to cover the entire system, but they must be accurate and follow correct notation, as they serve as a reliable reference for the system’s structure and behavior.</p>
            </article>

            <article>
                <img src="assets\image1.png">
                <p>In model-based development, where models are used to generate source code, they must be both complete and correct. Precision is crucial because the models directly influence the implementation. This means even small differences in symbols—like stick vs. block arrowheads—must be used accurately, as they carry distinct meanings and errors could lead to incorrect system behavior.</p>
            </article>

        </section>

        <section>
            <article>
                <h2>5.1 Context Models</h2>
            
                <p>Early in system specification, it’s important to define the system boundaries—determining what functionality will be handled by the system itself and what will remain in the environment or be managed by other systems. This requires collaboration with stakeholders to decide which business processes will be automated and which will remain manual or external. Identifying overlaps with existing systems is also crucial to avoid redundancy. Making these decisions early helps reduce system costs and simplifies requirements and design. In some cases, the boundary is obvious—such as replacing an old system—while in others, it must be clarified during requirements engineering.</p>

                <p>When specifying a system like a patient information system for mental healthcare (MHC-PMS), a key decision is whether it should only manage consultation and treatment data, or also store personal patient information. Relying on other systems for personal data avoids duplication, but introduces risks: it may slow down access and make the system dependent on the availability of external systems. If those systems fail, the MHC-PMS may become unusable, highlighting the trade-off between efficiency and reliability.</p>
            </article>

            <article>
                <img src="assets\figure5.1.png">
                <figcaption><strong>Figure 5.1: </strong>The context of the MHC-PMS</figcaption>
                
                <p>Defining a system boundary is not purely a technical decision—it can be influenced by social and organizational factors. For example, boundaries might be set to keep analysis within a single site, avoid dealing with difficult stakeholders, or even inflate project scope to justify expanding a development team. Once boundary decisions are made, the next step is to analyze the system's context—identifying how it interacts with its environment. This usually begins with creating a simple architectural model to illustrate key components and external dependencies.</p>

                <p>Figure 5.1 presents a context model for the mental health patient information system (MHC-PMS), illustrating its interactions with other systems in its environment. It shows that the MHC-PMS is connected to:</p>

                <ul>
                    <li>An appointments system</li>
                    <li>A general patient record system (for shared patient data)</li>
                    <li>A management reporting system</li>
                    <li>A hospital bed allocation system</li>
                    <li>A statistics system (used for research)</li>
                    <li>A prescription system (used to generate medication prescriptions)</li>
                </ul>
            </article>

            <article>
                <p>Context models typically show the system’s environment, including other automated systems, but they don’t detail the types of relationships between these systems and the one being specified. External systems might produce, consume, or share data with the system, and connections can vary—networked or not, co-located or remote. These relationship details impact the system’s requirements and design and must be considered. Therefore, simple context models are used alongside other models, like business process models, which describe the human and automated workflows involving these systems.</p>

                <img src="assets\figure5.2.png">  
                <figcaption><strong>Figure 5.2: </strong>Process model of involuntary detention</figcaption>
                
                <p>Figure 5.2 illustrates a key system process using a UML activity diagram that depicts how the MHC-PMS supports managing patients who may need to be detained involuntarily for their own or others’ safety, under strict legal safeguards that require regular reviews.</p>
                <p>The diagram shows the flow of control between activities, starting with a filled circle and ending with a filled circle inside another circle. Activities (rounded rectangles) represent specific subprocesses, and arrows show the sequence of work. The diagram also uses the UML stereotype feature to identify different supporting systems involved.</p>
                <p>A solid bar indicates synchronization points: when multiple activities lead to one bar, all must complete before moving on; when flow moves from a bar to multiple activities, those can run in parallel. For example, in Figure 5.2, informing social care and the patient’s next of kin, and updating the detention register, can happen concurrently.</p>
            </article> 
        </section>

        <section>
            <article>
                <h2>5.2 Interaction models</h2>
                <p>All systems involve some form of interaction—between users and the system, between the system and other systems, or among components within the system. Modeling these interactions is crucial: user interaction models help identify user requirements; system-to-system interaction models reveal potential communication issues; and component interaction models help assess whether the system’s structure can meet performance and reliability goals.</p>
                <p>Two key approaches to interaction modeling are:</p>
                <ol>
                    <li>Use case modeling—primarily captures interactions between the system and external actors, like users or other systems.</li>
                    <li>Sequence diagrams—detail interactions between system components and may include external agents.</li>
                </ol>
                <p>Use case models provide a high-level overview, while sequence diagrams offer detailed views of interactions within those use cases. Although UML also supports communication diagrams for modeling interactions, they are essentially alternative views of sequence diagrams and thus are not discussed here. Some tools even generate communication diagrams automatically from sequence diagrams.</p>
            </article>

            <article>
                <h3>5.2.1 Use case modeling</h3>

                <p>Use case modeling, developed by Jacobson et al. in the 1990s and included in the first UML release, is widely used for requirements elicitation. A use case represents a simple scenario describing what a user expects from a system, focusing on a discrete task involving external interaction.</p>
                <p>Graphically, a use case is depicted as an ellipse, with involved actors shown as stick figures. For example, Figure 5.3 illustrates a use case from the MHC-PMS where the system uploads data to a more general patient record system. This general system maintains summary patient data, while the MHC-PMS records detailed consultation data.</p>

                <img src="assets\figure5.3.png">
                <figcaption><strong>Figure 5.3: </strong>Transfer-data use case</figcaption>

                <p>In the use case shown in Figure 5.3, there are two actors: the operator transferring the data and the patient record system. While stick figures were originally meant to represent humans, they are now also used to depict external systems or hardware.</p>
                <p>Formally, use case diagrams use lines without arrows, since arrows in UML typically indicate message flow direction, but in use cases, messages flow both ways. However, in Figure 5.3, arrows are used informally to show that the medical receptionist initiates the transaction and data flows to the patient record system.</p>
                <p>Use case diagrams provide a simple overview of interactions but lack detail. To better understand the use case, more detailed descriptions are needed, which can be in the form of textual explanations, structured tables, or sequence diagrams. The choice depends on the use case and the required detail level, with tabular descriptions often being the most practical. Figure 5.4 shows such a tabular description for the ‘Transfer data’ use case.</p>
                <p>Composite use case diagrams combine multiple use cases into one view. Sometimes, all interactions with a system can be shown in a single composite diagram, but often this isn’t feasible due to the sheer number of use cases. In those situations, you create several diagrams, each focusing on related use cases. For example, Figure 5.5 presents all the use cases involving the actor Medical Receptionist in the MHC-PMS, grouping relevant interactions for clarity.</p>

                <img src="assets\figure5.4.png">
                <figcaption><strong>Figure 5.4: </strong>Tabular description of the ‘Transfer data’ use case</figcaption>

                <img src="assets\figure5.5.png">
                <figcaption><strong>Figure 5.5: </strong>Use cases involving the role ‘medical receptionist’</figcaption>

            </article>

            <article>
                <h3>5.2.2 Sequence diagrams</h3>

                <p>Sequence diagrams in UML are primarily used to model the order of interactions between actors and system objects, as well as inter-object communication. While UML offers a rich and detailed syntax for capturing various interaction types, this section focuses on the fundamentals.</p>
                <p>As the name suggests, a sequence diagram represents the chronological flow of messages in a specific use case or scenario. For example, Figure 5.6 illustrates the interactions involved in the "View patient information" use case, where a medical receptionist accesses certain patient details. This diagram helps visualize how different parts of the system collaborate over time to fulfill that request.</p>
                <p>In a UML sequence diagram, the actors and objects involved in the interaction are listed horizontally across the top. From each of these, a vertical dotted line (called a lifeline) extends downward, representing that entity's activity over time.</p>
                <p>Interactions between these entities—such as method calls or messages—are shown as horizontal arrows, annotated with details like the method name, parameters, and return values. A rectangle on a lifeline indicates when the object is actively participating in the interaction (its "activation" period).</p>
                <p>The sequence of events is read from top to bottom, showing the order in which actions occur.</p>
                <p>Additionally, if there are alternative flows in the process, an "alt" box is used. Each alternative is labeled with a condition in square brackets, indicating under what circumstances each branch is executed.</p>

                <img src="assets\figure5.6.png">
                <figcaption><strong>Figure 5.6: </strong>Sequence diagram for the ‘View patient information’ use case</figcaption>

                <p>You can read Figure 5.6 as follows:</p>
                <ol>
                    <li>In the sequence diagram (Figure 5.6), the medical receptionist initiates the interaction by calling the ViewInfo method on an instance P of the PatientInfo object class. The receptionist provides the patient's identifier (PID) as an input. The object P is a user interface element—specifically, a form that displays the patient's information on the screen.</li>
                    <li>After receiving the patient ID, the instance P (the user interface object) makes a call to the database to retrieve the required patient information. It also sends the receptionist’s identifier (UID) along with the request to enable security checking. At this point in the model, the source of the UID is not important—it is assumed to be available for authentication purposes.</li>
                    <li>The database then contacts an authorization system to verify whether the user (medical receptionist) is authorized to access the requested patient information. This security check ensures that only users with the appropriate permissions can perform this action.</li>
                    <li>If the authorization is successful, the patient information is retrieved from the database and used to populate the form on the medical receptionist’s screen. However, if the authorization fails, the system returns an error message instead of the data, indicating that access is denied.</li>
                </ol>

                <img src="assets\figure5.7.png">
                <figcaption><strong>Figure 5.7: </strong>Sequence diagram for transfer data</figcaption>

                <p>Figure 5.7 illustrates a sequence diagram from the MHC-PMS that introduces two new modeling features:</p>
                <ul>
                    <li>Direct actor-to-actor communication, and</li>
                    <li>Dynamic object creation during an operation sequence.</li>
                </ul>
                <p>The flow of the diagram can be understood as follows:</p>
                <ol>
                    <li>The medical receptionist logs in to the Patient Record System (PRS).</li>
                    <li>Two transfer options are available:</li>
                    <ul>
                        <li>Direct transfer of updated patient information.</li>
                        <li>Transfer of summary health data from the MHC-PMS to the PRS.</li>
                    </ul>
                    <li>In both cases, the authorization system is used to verify the receptionist’s access permissions.</li>
                    <li>Depending on the selected action:</li>
                    <ul>
                        <li>Personal information may be transferred directly from the user interface to the PRS, or</li>
                        <li>A Summary object is created from the database, and that summary is uploaded to the PRS.</li>
                    </ul>
                    <li>Once the transfer is complete, the PRS sends a status message, and the receptionist logs off.</li>
                </ol>
                <p>This diagram shows how system interactions can involve both direct communication and runtime object creation, adding depth to the modeling of system behavior.</p>
                <p>This point emphasizes the level of detail needed in sequence diagrams based on their purpose. If you're using sequence diagrams during early phases of system development, such as for requirements engineering or high-level design, you don’t need to include every interaction, especially those that depend on later implementation choices.</p>
                <p>For instance, in Figure 5.7, the method for obtaining the user identifier to check authorization can be delayed until the implementation phase. While the User object might be involved in the final system, this detail is unnecessary at the early design stage. By leaving out such specifics, the diagram stays focused on core system behavior without getting bogged down in decisions that are yet to be made.</p>
                <p>Thus, sequence diagrams at this stage should prioritize key interactions and general workflows, while more detailed interactions can be added later when the design and implementation choices are clearer.</p>
            </article>

            <article>
                <h2>5.3 Structural models</h2>
                <p>Structural models represent a system's components and their relationships. These can be static models (showing the system's design) or dynamic models (showing how the system behaves during execution). While static models focus on system architecture, dynamic models illustrate its runtime behavior.</p>
                <p>In architectural design, UML component, package, and deployment diagrams are commonly used. This section specifically focuses on class diagrams to model the static structure of an object-oriented system.</p>

                <h3>5.3.1 Class diagrams</h3>
                <p>Class diagrams are used in object-oriented systems to represent the classes and their associations. A class defines a type of object in the system, while an association indicates a relationship between classes. Initially, classes represent real-world entities (like patients or prescriptions), but as development progresses, additional implementation objects are added for system functionality.</p>
                <p>Class diagrams in UML can vary in detail. Early models focus on identifying essential real-world objects and their relationships. A simple class diagram, for example, may just show class names and associations, like the Patient and Patient Record classes with a connecting line to indicate their relationship.</p>

                <img src="assets\figure5.8.png">
                <figcaption><strong>Figure 5.8: </strong>UML classes and association</figcaption>

                <p>In Figure 5.8, class diagrams can also indicate the multiplicity of associations. In this case, the 1:1 relationship means that each Patient has one Patient Record, and vice versa. Other types of multiplicities are also possible, such as specifying a many-to-many relationship with a * (wildcard), indicating an indefinite number of associated objects.</p>
                <p>In Figure 5.9, the diagram extends to show that Patients are linked to multiple other classes, and associations can be named to clarify the nature of the relationship. Additionally, the role of each object in the relationship can be specified, providing more context to the interaction between classes.</p>
                <p>At this level, class diagrams resemble semantic data models, which are typically used in database design to represent data entities, their attributes, and relationships between them. The concept was introduced in the 1970s by Chen and further developed by Codd and others.</p>
                <p>While UML doesn't have a specific notation for semantic data modeling (since it focuses on object-oriented design), you can still represent a semantic model using object classes (representing entities), attributes (as class attributes), and associations (as relationships between classes). Essentially, semantic data models can be seen as a simpler form of object classes, lacking operations but focusing on data structure.</p>

                <img src="assets\figure5.9.png">
                <figcaption><strong>Figure 5.9: </strong>Classes and associations in the MHC-PMS</figcaption>

                <img src="assets\figure5.10.png">
                <figcaption><strong>Figure 5.10: </strong>The consultation class</figcaption>

                <p>To add detail to a class diagram, you can extend the simple class rectangle by including attributes and operations.</p>
                <ul>
                    <li>Attributes define the characteristics of an object (e.g., a Patient object might have an Address attribute).</li>
                    <li>Operations represent actions or methods that can be performed on the object (e.g., a ChangeAddress operation that updates a patient's address when they move).</li>
                </ul>
                <p>These are added inside the class rectangle, typically with attributes listed in the top section and operations in the bottom section, creating a more detailed representation of the class.</p>
                <p>This is illustrated in Figure 5.10 where:</p>
                <ol>
                    <li>The name of the object class is in the top section.</li>
                    <li>The class attributes are in the middle section. This must include the attribute names and, optionally, their types.</li>
                    <li>The operations (called methods in Java and other OO programming languages) associated with the object class are in the lower section of the rectangle.</li>
                </ol>
                <p>Figure 5.10 outlines the Consultation class, which includes both attributes and operations. The attributes capture key details of the consultation, such as Date, Duration, and PatientID to identify the patient involved. The operations include RecordVoiceNote, where doctors can record audio notes during the consultation, which are later transcribed, and GeneratePrescription, which allows the doctor to create an electronic prescription for medication. This model illustrates the key processes involved in handling consultations and prescriptions within the system.</p>
            </article>

            <article>
                <h3>5.3.2 Generalization</h3>
                <p>Generalization is a technique used to simplify complex systems by grouping entities into broader categories. Instead of focusing on the specific characteristics of each individual entity, we classify them into more general types (such as animals, cars, or houses). This approach enables us to identify common traits shared by all members of a class. For instance, squirrels and rats are both rodents, so we can generalize that all rodents have teeth for gnawing. This method helps reduce complexity and makes it easier to apply general rules or statements across similar entities.</p>
                
                <img src="assets\figure5.11.png">
                <figcaption><strong>Figure 5.11: </strong>A Generalization in hierarchy</figcaption>

                <p>In system modeling, generalization helps to consolidate common attributes and behaviors into a single class, reducing redundancy and simplifying maintenance. By grouping related classes under a more general parent class, changes to common properties only need to be made in one place. This practice enhances efficiency, as modifications are automatically inherited by all subclasses. In object-oriented languages like Java, generalization is achieved through class inheritance.</p>
                <p>The UML uses a specific notation for generalization, represented by an arrow with a hollow triangle pointing towards the parent class. For example, in a medical system, "General Practitioner" and "Hospital Doctor" can be generalized as "Doctor." Furthermore, the "Hospital Doctor" class can be further specialized into subclasses such as "Trainee Doctor," "Registered Doctor," and "Consultant," each with distinct responsibilities and levels of expertise.</p>
                <p>In a generalization hierarchy, lower-level (subclass) classes inherit the attributes and operations of their higher-level (superclass) classes. This inheritance means that subclasses automatically have all the attributes and operations defined in the superclass, but they can also introduce more specific attributes and operations that are unique to them. For example, all doctors (the superclass) will have common attributes like "name" and "phone number," but hospital doctors (a subclass) will also have attributes like "staff number" and "department," which general practitioners (another subclass) do not need. Instead, general practitioners may have attributes like "practice name" and "address," as they work independently. In Figure 5.12, this generalization hierarchy is shown, where the class "Doctor" has operations for registering and de-registering doctors within the MHC-PMS system. Subclasses like "Hospital Doctor" and "General Practitioner" can extend or modify this base functionality to suit their specific needs.</p>
                
                <img src="assets\figure5.12.png">
                <figcaption><strong>Figure 5.12: </strong>A generalization hierarchy with added detail</figcaption>
            </article>

            <article>
                <h3>5.3.3 Aggregation</h3>
                <p>In system modeling, aggregation is used to represent the relationship where one object (the whole) is composed of other objects (the parts). For example, a study pack may consist of a book, PowerPoint slides, quizzes, and reading recommendations. In UML, aggregation is depicted using a diamond shape next to the class that represents the whole object. For instance, in Figure 5.13, a "Patient Record" is shown as an aggregation of "Patient" and an indefinite number of "Consultations," indicating that the patient record is composed of these components. This illustrates how objects can be structured from other, smaller objects.</p>
            </article>
        </section>

        <section>
            <article>
                <h2>5.4 Behavioral models</h2>
                <p>Behavioral models represent the dynamic aspects of a system during its execution, showing how the system responds to stimuli from its environment. These stimuli can be of two types:</p>
                <ol>
                    <li>Data: This refers to incoming data that the system needs to process.</li>
                    <li>Events: These are actions or occurrences that trigger specific system processes. Events may or may not be associated with data.</li>
                </ol>
                <p>Behavioral models help illustrate how the system behaves over time in response to these inputs.</p>

                <img src="assets\figure5.13.png">
                <figcaption><strong>Figure 5.13: </strong>The aggregation association</figcaption>

                <img src="assets\image2.png">
                <p>Business systems often fall into two categories based on how they are driven:</p>

                <ol>
                    <li>Data-Driven Systems: These systems are primarily controlled by the data they receive. Their processing involves actions on this data and the generation of outputs. For example, a phone billing system processes data about customer calls, calculates costs, and generates a bill.</li>
                    <li>Event-Driven Systems: These systems are triggered by specific events rather than data. They perform minimal data processing. A real-time system like a landline phone switching system responds to events such as a "receiver off hook" to generate a dial tone, or key presses to capture a phone number.</li>
                </ol>
            </article>

            <article>
                <h3>5.4.1 Data-driven modeling</h3>
                <p>Data-driven models illustrate the sequence of actions involved in processing input data and generating output. They are especially useful during requirements analysis, as they show the end-to-end processing of data—how it moves through the system from input to output.</p>
                <p>In the 1970s, methods like DeMarco’s Structured Analysis introduced Data Flow Diagrams (DFDs) to model data processing. These models helped analysts and designers understand the movement of data through a system and were simple and intuitive for explaining system processes to users.</p>
                <p>Although UML does not support traditional DFDs, it introduced activity diagrams in UML 2.0, which are similar in purpose. These diagrams show the processing steps (activities) and the flow of data (represented as objects). For example, an insulin pump software model can use activity diagrams to depict the processing sequence and data interactions, much like data-flow diagrams did.</p>

                <img src="assets\figure5.14.png">
                <figcaption><strong>Figure 5.14: </strong>An activity model of the insulin pump’s operation</figcaption>

                <p>An alternative to using data-driven models for depicting sequence processing is through UML sequence diagrams. While sequence diagrams are typically used to model interactions, they can also represent sequential data processing by showing messages that flow from left to right. For example, in Figure 5.15, a sequence diagram models the processing of an order and sending it to a supplier.</p>
                <p>Unlike data-flow diagrams, which emphasize system functions, sequence diagrams focus on the objects involved in the system. This makes sequence diagrams useful for illustrating how objects interact and how data is processed in a sequential manner. The equivalent data-flow diagram for the same order processing system can be found on the book’s web pages for comparison.</p>
            </article>

            <article>
                <h3>5.4.2 Event-driven modeling</h3>
                <p>Event-driven modeling focuses on how a system responds to external and internal events. It operates on the premise that a system has a finite number of states, and that events or stimuli trigger transitions between these states. For instance, in a system controlling a valve, an event such as an operator command may cause the system to transition from the state "Valve open" to "Valve closed." This approach is particularly useful for real-time systems, where the system must respond to events as they occur. Event-based modeling was first introduced in real-time design methods by Ward and Mellor (1985) and Harel (1987, 1988).</p>

                <img src="assets\figure5.15.png">
                <figcaption><strong>Figure 5.15: </strong>Order processing</figcaption>

                <img src="assets\figure5.16.png">
                <figcaption><strong>Figure 5.16: </strong>A state diagram of a microwave oven</figcaption>

                <p>The UML supports event-based modeling through state diagrams, which are based on Statecharts (Harel, 1987, 1988). These diagrams represent the different system states and the events that trigger transitions from one state to another. While state diagrams don’t display data flow within the system, they can include information about the computations that occur within each state.</p>
                <p>To illustrate event-driven modeling, a simple example of microwave control software is used. While real microwave ovens are far more complex, this simplified version is easier to understand. The basic microwave system includes a power switch (for full or half power), a numeric keypad to input cooking time, a start/stop button, and an alphanumeric display. This system's behavior can be modeled using a state diagram to capture the transitions between states, such as "Waiting for input," "Cooking," and "Paused."</p>
                <p>I have assumed that the sequence of actions in using the microwave is:</p>
                <ol>
                    <li>Select the power level (either half power or full power).</li>
                    <li>Input the cooking time using a numeric keypad.</li>
                    <li>Press Start and the food is cooked for the given time.</li>
                </ol>
                <p>In a UML state diagram, system states are represented by rounded rectangles, each of which can include a brief description of the actions that occur in that state, often following a "do" keyword. Labeled arrows indicate the events or stimuli that trigger transitions from one state to another. The start and end states can be shown using filled circles, similar to the notation in activity diagrams.</p>
                <p>For the microwave example, the state diagram would include states like "Waiting for Input," "Cooking," and "Paused." Safety checks such as ensuring the door is closed before cooking starts could be modeled as conditions or guards on the transitions. When cooking is complete, an event (like the cooking timer finishing) would trigger the "Completion" state, where the buzzer sounds as an alert. The alphanumeric display can show various warnings, like "Door Open" or "Cooking Complete," depending on the current state.</p>
                <p>In Figure 5.16, the state diagram begins with the system in a "Waiting" state, where it awaits user input. The system responds to either the full-power or half-power button being pressed, which allows the user to select the desired power level. If the user changes their mind, they can press the other button to switch the power level.</p>
                <p>Once the time is set and if the door is closed, the Start button becomes enabled. Pressing the Start button transitions the system into the "Cooking" state. During the cooking process, the microwave operates for the specified duration. After the cooking cycle ends, the system returns to the "Waiting" state, ready for the next user interaction.</p>
                <p>This flow clearly defines the user interactions and system responses, and can be represented as transitions in a UML state diagram, with each state and event triggering specific actions or conditions.</p>

                <img src="assets\figure5.17.png">
                <figcaption><strong>Figure 5.17: </strong>States and stimuli for the microwave oven</figcaption>

                <p>The UML notation allows for the inclusion of detailed activities within each state. For example, Figure 5.17 provides a tabular description of each state, specifying the stimuli that trigger state transitions. This level of detail is important in system specification, where understanding the exact conditions for state changes is crucial.</p>
                <p>However, state-based modeling can become cumbersome as the number of states in the system grows, especially for larger systems. To manage this complexity, you can use the concept of superstates, which group multiple related states under a single higher-level state. This approach allows you to hide complexity in the high-level model and expand it when needed for greater detail.</p>
                <p>For instance, in Figure 5.18, the Operation state is a superstate. This superstate is expanded to reveal its substates, which include:</p>
                <ul>
                    <li>Status check: The system checks for any problems.</li>
                    <li>Alarm: If any issues are found, an alarm is triggered and the system enters a disabled state.</li>
                    <li>Cooking: The microwave runs for the specified time.</li>
                    <li>Buzzer: After cooking, a buzzer sounds to indicate completion.</li>
                    <li>Door open: If the door is opened during operation, the system enters the disabled state, as shown in Figure 5.15.</li>
                </ul>
                <p>This hierarchical approach helps manage the complexity by abstracting lower-level states into more manageable superstates, while still allowing for detailed breakdowns when needed.</p>

                <img src="assets\figure5.18.png">
                <figcaption><strong>Figure 5.18: </strong>Microwave oven operation</figcaption>
            </article>
        </section>

        <section>
            <article>
                <h2>5.5 Model-driven engineering</h2>
            </article>
        </section>

    </main>
    
</body>
</html>