<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Agile Software Development</title>
</head>
<body>

  <main>

    <header style="text-align:right; font-family:Arial, sans-serif; font-size:14px;">
      Chapter 3 &nbsp; Agile software development
    </header>

    <section>
      <h1>3</h1>
      <h1>Agile software development</h1>
      <img src="./ChapterThree/pic.jpg" alt="Agile illustration">
    </section>

    <section>
      <h2>Objectives</h2>
      <p>
        The objective of this chapter is to introduce you to agile software development methods.
        When you have read the chapter, you will:
      </p>
      <ul>
        <li>understand the rationale for agile software development methods, the agile manifesto,
            and the differences between agile and plan-driven development;</li>
        <li>know the key practices in extreme programming and how these relate to the general principles
            of agile methods;</li>
        <li>understand the Scrum approach to agile project management;</li>
        <li>be aware of the issues and problems of scaling agile development methods to the development
            of large software systems.</li>
      </ul>
    </section>

    <section>
      <h2>Contents</h2>
      <ol>
        <li>Agile methods</li>
        <li>Plan-driven and agile development</li>
        <li>Extreme programming</li>
        <li>Agile project management</li>
        <li>Scaling agile methods</li>
      </ol>
    </section>

    <section>
      <article>
        <p>
          Businesses now operate in a global, rapidly changing environment. They have to
          respond to new opportunities and markets, changing economic conditions, and the
          emergence of competing products and services. Software is part of almost all business operations so new software is developed quickly to take advantage of new
          opportunities and to respond to competitive pressure. Rapid development and delivery is therefore now often the most critical requirement for software systems. In fact,
          many businesses are willing to trade off software quality and compromise on
          requirements to achieve faster deployment of the software that they need.
        </p>
        <p>
          Because these businesses are operating in a changing environment, it is often practically impossible to derive a complete set of stable software requirements. The initial
          requirements inevitably change because customers find it impossible to predict how a
          system will affect working practices, how it will interact with other systems, and what
          user operations should be automated. It may only be after a system has been delivered
          and users gain experience with it that the real requirements become clear. Even then,
          the requirements are likely to change quickly and unpredictably due to external factors. The software may then be out of date when it is delivered.
        </p>
        <p>
          Software development processes that plan on completely specifying the requirements
          and then designing, building, and testing the system are not geared to rapid software
          development. As the requirements change or as requirements problems are discovered,
          the system design or implementation has to be reworked and retested. As a consequence,
          a conventional waterfall or specification-based process is usually prolonged and the final
          software is delivered to the customer long after it was originally specified.
        </p>
        <p>
          For some types of software, such as safety-critical control systems, where a complete analysis of the system is essential, a plan-driven approach is the right one.
          However, in a fast-moving business environment, this can cause real problems. By
          the time the software is available for use, the original reason for its procurement may
          have changed so radically that the software is effectively useless. Therefore, for business systems in particular, development processes that focus on rapid software
          development and delivery are essential.
        </p>
        <p>
          The need for rapid system development and processes that can handle changing
          requirements has been recognized for some time. IBM introduced incremental
          development in the 1980s (Mills et al., 1980). The introduction of so-called fourth-
          generation languages, also in the 1980s, supported the idea of quickly developing
          and delivering software (Martin, 1981). However, the notion really took off in the
          late 1990s with the development of the notion of agile approaches such as DSDM
          (Stapleton, 1997), Scrum (Schwaber and Beedle, 2001), and extreme programming
          (Beck, 1999; Beck, 2000).
        </p>
        <p>
          Rapid software development processes are designed to produce useful software
          quickly. The software is not developed as a single unit but as a series of increments, with
          each increment including new system functionality. Although there are many
          approaches to rapid software development, they share some fundamental characteristics:
        </p>
        <header style="display:flex; align-items:center; font-family:Arial, sans-serif; font-size:16px; border-bottom:2px solid #ccc; padding:6px 0; margin-bottom:15px;">
  <span style="font-weight:bold;">Chapter 3</span>
  <span style="margin:0 8px;"></span>
  <span>Agile software development</span>
</header>
        <ol>
          <li>
            The processes of specification, design, and implementation are interleaved.
            There is no detailed system specification, and design documentation is minimized
            or generated automatically by the programming environment used to
            implement the system. The user requirements document only defines the most important characteristics of the system.
          </li>
          <li>
            The system is developed in a series of versions. End-users and other system
            stakeholders are involved in specifying and evaluating each version. They may
            propose changes to the software and new requirements that should be implemented
            in a later version of the system.
          </li>
          <li>
            System user interfaces are often developed using an interactive development
            system that allows the interface design to be quickly created by drawing and placing
            icons on the interface. The system may then generate a web-based interface for
            a browser or an interface for a specific platform such as Microsoft Windows.
          </li>
        </ol>
        <p>
          Agile methods are incremental development methods in which the increments are
          small and, typically, new releases of the system are created and made available to customers every two or three weeks. They involve customers in the development process
          to get rapid feedback on changing requirements. They minimize documentation by
          using informal communications rather than formal meetings with written documents.
        </p>
      </article>
    </section>
<h4>Agile methods</h4>
<p>
    In the 1980s and early 1990s, there was a widespread view that the best way to
achieve better software was through careful project planning, formalized quality
assurance, the use of analysis and design methods supported by CASE tools, and
controlled and rigorous software development processes. This view came from the
software engineering community that was responsible for developing large, long lived software systems such as aerospace and government systems.
</p>
<p>
    This software was developed by large teams working for different companies. Teams
were often geographically dispersed and worked on the software for long periods of
time. An example of this type of software is the control systems for a modern aircraft,
which might take up to 10 years from initial specification to deployment. These plandriven approaches involve a significant overhead in planning, designing, and documenting the system. This overhead is justified when the work of multiple development teams
has to be coordinated, when the system is a critical system, and when many different
people will be involved in maintaining the software over its lifetime.
</p>
<p>
    However, when this heavyweight, plan-driven development approach is applied
to small and medium-sized business systems, the overhead involved is so large that it
dominates the software development process. More time is spent on how the system
should be developed than on program development and testing. As the system
requirements change, rework is essential and, in principle at least, the specification
and design has to change with the program.
</p>
<p>
    Dissatisfaction with these heavyweight approaches to software engineering led a
number of software developers in the 1990s to propose new ‘agile methods’. These
allowed the development team to focus on the software itself rather than on its design
</p>

<p><strong>3.1 Agile methods</strong></p>
<hr>

     <section>
         <article>
<p> 
    and documentation. Agile methods universally rely on an incremental approach to software specification, development, and delivery. They are best suited to application development where the system requirements usually change rapidly during the development process.
They are intended to deliver working software quickly to customers, who can then propose new and changed requirements to be included in later iterations of the system. They aim to cut down on process bureaucracy by avoiding work that has dubious long-term value 
and eliminating documentation that will probably never be used. </p> 
<p> The philosophy behind agile methods is reflected in the agile manifesto that was agreed on by many of the leading developers of these methods. 
This manifesto states: </p> <blockquote> <p><em>We are uncovering better ways of developing software by doing it and helping others do it. 
Through this work we have come to value:</em></p> <ul style="list-style:none; padding-left:0;"> <li><em>Individuals and interactions over processes
and tools</em></li> <li><em>Working software over comprehensive documentation</em></li> <li><em>Customer collaboration over contract negotiation</em></li> <li><em>Responding to change over 
following a plan</em></li> </ul> <p><em>That is, while there is value in the items on the right, we value the items on the left more.</em></p> </blockquote> <p> Probably the best-known agile method 
is extreme programming (Beck, 1999; Beck, 2000), which I describe later in this chapter. Other agile approaches include Scrum (Cohn, 2009; Schwaber, 2004; Schwaber and Beedle, 2001), 
Crystal (Cockburn, 2001; Cockburn, 2004), Adaptive Software Development (Highsmith, 2000), DSDM (Stapleton, 1997; Stapleton, 2003), and Feature Driven Development (Palmer and Felsing, 2002). 
Assessments of agile methods based on experience have led to the notion of agile modeling (Ambler and Jeffries, 2002) and agile instantiations of the Rational Unified Process (Larman, 2002). </p>
<p>
    Although these agile methods are all based around the notion of incremental development and delivery, they propose different processes to achieve this. However, they share a set of principles, based on 
the agile manifesto, and so have much in common. These principles are shown in Figure 3.1. Different agile methods instantiate these principles in different ways and I don’t have space to discuss all agile methods. 
Instead, I focus on two of the most widely used methods: extreme programming (Section 3.3) and Scrum (Section 3.4). </p> 
<p> 
    Agile methods have been very successful for some types of system development: </p> 
    <ol> 
        <li>
Product development where a software company is developing a small or medium-sized product for sale.</li>
<li>
    Custom system development within an organization, where there is a clear commitment from the customer to become involved in the development process and where there are not a lot of external rules 
and regulations that affect the software.
</li>
</ol>
</article>
</section>
</main>


     <section>
         <header>Chapter 3 &nbsp; Agile software development</header>
          <hr>
         </section>

          <section>
             
            <article>

<table border="1" cellpadding="6" cellspacing="0"> 
    <thead>
         <tr>
             <th>Principle</th> 
             <th>Description</th>
             </tr>
             </thead>
              <tbody>
                 <tr>
                     <td>Customer involvement</td>
                      <td>Customers should be closely involved throughout the development process. Their role is to provide and prioritize
new system requirements and to evaluate the iterations of the system.</td>
  </tr>
   <tr>
     <td>Incremental delivery</td>
      <td>The software is developed 
in increments with the customer specifying the requirements to be included in each increment.</td>
 </tr> <tr> 
    <td>People not process</td>
     <td>The skills of the development team should be recognized and exploited. Team members should be left to develop their own ways of working without 
prescriptive processes.</td>
 </tr> 
 <tr>
     <td>Embrace change</td>
      <td>Expect the system requirements to change and design the system to accommodate 
these changes.</td>
 </tr>
  <tr>
     <td>Maintain simplicity</td>
      <td>Focus on simplicity in both the software being developed and in the development 
process. Wherever possible, actively work to eliminate complexity from the system.</td>
 </tr>
 </tbody>
 </table>
  <figcaption>Figure 3.1 The principles of agile methods</figcaption> </figure> <p> As I discuss in the final section of this chapter, the
 success of agile methods has meant that there is a lot of interest in using these methods for other types of software development. However, 
 because of their focus on small, tightly integrated teams, there are problems in scaling them to large systems. There have also been experiments 
 in using agile approaches for critical systems engineering (Drobna et al., 2004). However, because of the need for security, safety, and dependability
  analysis in critical systems, agile methods require significant modification before they can be routinely used for critical systems engineering. 
</p> 
<p>
    In practice, the principles underlying agile methods are sometimes difficult to realize:</p>
     <ol>
         <li>
Although the idea of customer involvement in the development process is an attractive one, its success depends on having a customer who is willing and
able to spend time with the development team and who can represent all system stakeholders. Frequently, the customer representatives are subject to
other pressures and cannot take full part in the software development.
</li> 
<li>
    Individual team members may not have suitable personalities for the intense involvement that is typical of agile methods, and therefore not interact well 
with other team members.
</li>
 <li>
    Prioritizing changes can be extremely difficult, especially in systems for which there are many stakeholders. Typically, each stakeholder gives
different priorities to different changes.</li> <li>Maintaining simplicity requires extra work. Under pressure from delivery schedules, the team members
may not have time to carry out desirable system simplifications.
</li>
 </ol>
 </article>
 </section>
 </main>

 <section>
  <article>
    <p><strong>3.1 Agile methods</strong></p>
    <hr>

    <ol start="5">
      <li>Many organizations, especially large companies, have spent years changing their culture so that processes are defined and followed. It is difficult for them to move to a working model in which processes are informal and defined by development teams.</li>
    </ol>

    <p>Another non-technical problem—that is a general problem with incremental development and delivery—occurs when the system customer uses an outside organization for system development. The software requirements document is usually part of the contract between the customer and the supplier. Because incremental specification is inherent in agile methods, writing contracts for this type of development may be difficult.</p>

    <p>Consequently, agile methods have to rely on contracts in which the customer pays for the time required for system development rather than the development of a specific set of requirements. So long as all goes well, this benefits both the customer and the developer. However, if problems arise then there may be difficult disputes over who is to blame and who should pay for the extra time and resources required to resolve the problems.</p>

    <p>Most books and papers that describe agile methods and experiences with agile methods talk about the use of these methods for new systems development. However, as I explain in Chapter 9, a huge amount of software engineering effort goes into the maintenance and evolution of existing software systems. There are only a small number of experience reports on using agile methods for software maintenance (Poole and Huisman, 2001). There are two questions that should be considered when considering agile methods and maintenance:</p>

    <ol>
      <li>Are systems that are developed using an agile approach maintainable, given the emphasis in the development process of minimizing formal documentation?</li>
      <li>Can agile methods be used effectively for evolving a system in response to customer change requests?</li>
    </ol>

    <p>Formal documentation is supposed to describe the system and so make it easier for people changing the system to understand. In practice, however, formal documentation is often not kept up to date and so does not accurately reflect the program code. For this reason, agile methods enthusiasts argue that it is a waste of time to write this documentation and that the key to implementing maintainable software is to produce high-quality, readable code. Agile practices therefore emphasize the importance of writing well-structured code and investing effort in code improvement. Therefore, the lack of documentation should not be a problem in maintaining systems developed using an agile approach.</p>

    <p>However, my experience of system maintenance suggests that the key document is the system requirements document, which tells the software engineer what the system is supposed to do. Without such knowledge, it is difficult to assess the impact of proposed system changes. Many agile methods collect requirements informally and incrementally and do not create a coherent requirements document.</p>
  </article>
</section>

<>
  <section>
    <article>
      <p>
        In respect, the use of agile methods is likely to make subsequent system maintenance
        more difficult and expensive.
      </p>
      <p>
        Agile practices, used in the maintenance process itself, are likely to be effective,
        whether or not an agile approach has been used for system development. Incremental
        delivery, design for change and maintaining simplicity all make sense when software
        is being changed. In fact, you can think of an agile development process as a process
        of software evolution.
      </p>
      <p>
        However, the main difficulty after software delivery is likely to be keeping customers
        involved in the process. Although a customer may be able to justify the full-time
        involvement of a representative during system development, this is less likely
        during maintenance where changes are not continuous. Customer representatives are
        likely to lose interest in the system. Therefore, it is likely that alternative mechanisms,
        such as change proposals, discussed in Chapter 25, will be required to create
        the new system requirements.
      </p>
      <p>
        The other problem that is likely to arise is maintaining continuity of the development
        team. Agile methods rely on team members understanding aspects of the
        system without having to consult documentation. If an agile development team is
        broken up, then this implicit knowledge is lost and it is difficult for new team members
        to build up the same understanding of the system and its components.
      </p>
      <p>
        Supporters of agile methods have been evangelical in promoting their use and
        have tended to overlook their shortcomings. This has prompted an equally extreme
        response, which, in my view, exaggerates the problems with this approach (Stephens
        and Rosenberg, 2003). More reasoned critics such as DeMarco and Boehm
        (DeMarco and Boehm, 2002) highlight both the advantages and disadvantages of
        agile methods. They propose a hybrid approach where agile methods incorporate
        some techniques from plan-driven development may be the best way forward.
      </p>
    </article>

    <article>
      <h2>3.2 Plan-driven and agile development</h2>
      
      <p>
        Agile approaches to software development consider design and implementation to be
        the central activities in the software process. They incorporate other activities, such as
        requirements elicitation and testing, into design and implementation. By contrast, a
        plan-driven approach to software engineering identifies separate stages in the software
        process with outputs associated with each stage. The outputs from one stage are
        used as a basis for planning the following process activity. Figure 3.2 shows the distinctions
        between plan-driven and agile approaches to system specification.
      </p>
      <p>
        In a plan-driven approach, iteration occurs within activities with formal documents
        used to communicate between stages of the process. For example, the requirements
        will evolve and, ultimately, a requirements specification will be produced.
        This is then an input to the design and implementation process. In an agile approach,
        iteration occurs across activities. Therefore, the requirements and the design are
        developed together, rather than separately.
      </p>
    </article>
  </section>
  

 

  </main>

</body>
</html>

